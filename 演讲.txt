1、vue生命周期
创建前后、挂载前后、更新前后、销毁前后（最重要的两个阶段就是就是创建后，他可以访问到data、methods、computed里面的数据，然后是挂载后，这个阶段就可以对dom节点进行一系列的操作了）
2、vue父传子和子传父
父传子：父亲用属性绑定，儿子用props接收
子传父：子组件用$emit，父组件用自定义事件接收
3、什么是原型链
原型链：是一种关系,实例对象的对象原型和构造函数的原型对象之间的关系,关系是通过对象原型(__proto__)来联系的；也就是说，实例对象的对象原型指向构造函数的原型，而构造函数的原型的对象原型指向object的原型，object的原型的对象原型指向null
4、ES6新特性
（1）let声明变量和const声明常量，两个都有块级作用域
（2）箭头函数
（3）模板字符串
（4）解构
（5）类的定义
（6）import、export导入导出
（7）async、await、promise等等
5、使用箭头函数应注意什么
（1）箭头函数的父亲指向谁，this就指向谁
（2）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
6、find()和 findIndex()
（1）find()方法，用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined
（2） findIndex() 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
7、filter()和forEach()
（1）filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组
（2）forEach()自动遍历整个数组，且无法break中途跳出循环，不可控，不支持return操作输出，return只用于控制循环是否跳出当前循环。
8、some() 和 every()
（1）every()

判断数组中是否每个元素都满足条件
只有都满足条件才返回true；
只要有一个不满足就返回false；
（2）some()

判断数组中是否至少有一个元素满足条件
只要有一个满足就返回true
只有都不满足时才返回false
9、map()和reduce()
（1）map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
（2）reduce()方法接收一个函数作为累加器，数组中的每个值(从左到右)开始合并,最终为一个值.
10、this的指向问题 
（1）普通函数this 指向window
（2）定时器函数this指向的是window
（3）立即执行函数this是指向window
（4）对象的方法中this指向的是对象
（5）构造函数this指向实例对象 原型对象里面的this 指向的也是实例对象
（6）绑定事件函数this指向的是函数的调用者
11、call()、apply()、bind()区别
相同点：都是改变函数中的this指向的。
（1）在调用情况下，bind 返回的是一个新的函数，调用的话要用括号调用，而call()和apply()是在原有的基础上自动执行。
（2）在传参情况下，call()和bind()的参数是直接放进去的，用逗号分隔；而apply()是的所有参数都必须放在一个数组里面传进去。
12、闭包
（1）闭包的概念:函数A中,有一个函数B，函数B中可以访问函数A中定义的变量或者是数据，此时形成了闭包。
（2）闭包的作用:缓存数据,延长作用域链；闭包的缺点:缓存数据，没有及时的释放。
13、继承
 继承: 首先继承是一种关系,类(class)与类之间的关系,JS中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承，继承也是为了数据共享,js中的继承也是为了实现数据共享，节省内存空间
（1）原型继承：为了数据共享,改变原型指向,做到了继承\\\通过改变原型指向实现的继承；缺陷:因为改变原型指向的同时实现继承,直接初始化了属性，继承过来的属性的值都是一样的。
（2）借用构造函数：解决了属性继承,并且值不重复的问题；缺陷:父级类别中的原型对象里的方法不能继承。
（3）组合继承：原型继承+借用构造函数继承，它既能解决属性问题,又能解决方法问题。
（4）拷贝继承：就是把对象中需要共享的属性或者犯法,直接遍历的方式复制到另一个对象中。
14、浮动和它的工作原理以及清除浮动的技巧
浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。
（1）后面添加空标签空标签
（2）overflow：hidden
（3）clear:both
（4）单伪：：before
（5）双伪